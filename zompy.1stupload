#!/usr/bin/env python3
# Snek : Snake and Adder (revised title)
# Copyright (C) 2020 Sigbj√∏rn "sigg3" Smelror <git@sigg3.net>.
#
# Snek is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 2 of the License.
#
# Snek is distributed in the hope that it will be useful and fun,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# URL: <https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>
#
# Submit issues and get updates at: <https://github.com/sigg3/snek>

import copy, shutil, shelve, curses, random, time
from pathlib import Path

# MODULES AND USAGE
# copy      deepcopying dead/alive grid/matrix # evaluate removal wrt. not being used
# shutil    dynamic terminal size detection    # evaluate removal wrt. curses
# shelve    save/load settings conf file 
# Path      access conf shelf file 
# curses    arrow keys and screen drawing
# random    some random ints
# time      for game flow (otherwise everything happens too fast)
# sys       for sys.exit() since Raise systemexit did not work :P

# TODO conway
# instead of a bool, we have 4 categories: dead, born, alive, static
#    Static cells remain there until game over. An alive cell becomes static if it survives N rounds.
# static cells grow like cancer. this makes the game harder and harder.

# TODO age
# zompy_map dict consist of zompy_map[x,y] = (category, age)
# where age 

# >>> zompy_map
# {(4, 3): (1, 0)}
# >>> zompy_map[4,3]
# (1, 0)
# >>> zompy_map[4,3][0] # how to read category
# 1
# >>> zompy_map[4,3][1] # how to read age
# 0


# TODO edibles
# +1 size


# DEBG NOTE
# Update_map() spews out debug_map.txt at the moment
# Note: from _running dir_

# ALso
# alternative to wrapper func.
# curses.initscr()      
# 
# screen = curses.newwin(HEIGHT, WIDTH, 0, 0)
# 
# screen.timeout(TIMEOUT)
# screen.keypad(1) 
# screen.noecho()
# curses.curs_set(0)
# screen.border(0)




# Note
# Method can be called through instance (snek.move) or through a class snake.move(snek)!

# TODO
# control and verify that all ranges now use 0-23 for 24 row etc.

# TODO
# When last I played, snek had no tail :Pz
# snake size was 2 (so that might be worth checking out)
# snake is shown as 1 size smaller than he is

# TODO
# bug in range
#    update_map(snek) # moves zombies and checks for collisions (if so snek.collision = True)
#  File "./zompy", line 287, in update_map
#    if zompy_map[xpos,ypos] == zompy_settings['chDead']:
#KeyError: (21, 24)

# TODO
# left and right arrow (arrow-keys) movements are reversed

# TODO
# check whether wasd works as intended.

# TODO
# Weird curses glitches
# die_msg in die() is printed over terminal prompt if prompt is empty

# TODO
# Remove redundant calls to: width, height = get_terminal_size()
# We already have these as universals in zompy_settings['width'] etc.


# TODO
# Diminish: when snake collides/is collided onto, subtract one block from its size

# TODO
# Snake death animation
# 9608	 	FULL BLOCK    # from
# 9619	 	DARK SHADE
# 9618	 	MEDIUM SHADE
# 9617	 	LIGHT SHADE   # to


# TODO
# Hot seat multiplayer
# In two-player mode, there's no highscore, but instead each player gets to enter his/her name


# TODO color schemes
# Allows the user to change the color scheme
# COLOR_BLACK
# COLOR_BLUE
# COLOR_CYAN # light blue
# COLOR_GREEN
# COLOR_MAGENTA # purple red
# COLOR_RED
# COLOR_WHITE
# COLOR_YELLOW
    
# TODO
# Note: legacy code uses x,y while curses lib uses y,x.
# TODO: Rewrite legacy code to use y,x instead (consistency reduces risk of typos)


def pseudorand():
    # Legacy replaced by librandom
    return random.randint(0,1)

def pseudorand_one_to_four():
    # Legacy replaced by librandom
    return random.randint(1,4)
    
def save_conf(zmpcfg):
    # write configuration to shelve file
    try:
        configFile = shelve.open(str(zmpcfg))
    except:
        die(err_code=6)
    
    if zompy_settings['debug']: print('Saving config to '+ str(zmpcfg))
    
    for key,value in zompy_settings.items():
        configFile[key] = value
        if zompy_settings['debug']: print(f'{key} => {value}')
    configFile.close()

def read_conf(zmpcfg):
    # read configuration from shelve file
    try:
        configFile = shelve.open(str(zmpcfg), flag='r')
    except:
        die(err_code=6)
    
    if zompy_settings['debug']: print('Loading config from '+ str(zmpcfg))
    
    for key,value in configFile.items():
        zompy_settings[key] = value
        if zompy_settings['debug']: print(f'{key} <= {value}')
    configFile.close()

def config_is_sane(zmpcfg):
    # sanity check of keys in zompy_settings (just in case)
    # If the key(s) in the file is not in the default settings set, we cannot trust it.
    # Return true if config is sane, False if it is not.
    try:
        configFile = shelve.open(str(zmpcfg), flag='r')
    except:
        die(err_code=6)
    
    if len(configFile.items()) != len(zompy_settings):
        configFile.close()
        die(err_code=5)
    for key in configFile.keys():
        if key not in zompy_settings.keys():
            print(f'Missing key {key} in {zmpcfg} :(',f'File might be corrupt or it might have been tampered with.',f'Please write \'YES\' to load anyway or hit Enter to use deafults: ', sep='\n', end='') # f-string limits us to v3.6 and newer.. oh, well
            uprompt = input()
            if uprompt.lower() == 'yes'or uprompt.lower() == 'y' :
                break
            else :
                configFile.close()
                return False
    configFile.close()
    return True

def get_terminal_size():
    # Returns curses friendly 79x23 for 80x24 term
    termCols,termRows = shutil.get_terminal_size(fallback=(80,24))
    if termCols < 80 and termRows < 24:
        termCols = 80
        termRows = 24
    return termCols-1, termRows-1

def set_terminal_size():
    zompy_settings['width'], zompy_settings['height'] = get_terminal_size()

def terminal_size_changed():
    # Ran in loop. Returns True if terminal has changed size
    curr_width, curr_height = get_terminal_size()
    if curr_width == zompy_settings['width'] and curr_height == zompy_settings['height'] :
        return False
    return True


def epoch_as_sec():
    # returns int of seconds since epoch
    return int(time.time())
    

#class cell:
#    # create a cell using: cell_X-Y = cell(X,Y)
#    def __init__(self, xpos, ypos, state):
#        self.xpos = xpos # static
#        self.ypos = ypos # static
#        self.state = state # dynamic (0==dead, 1==born/alive, 2==occuped)
#    
#    def get_state(self):
#        return self.state
#    
#    def set_state(self,state):
#        self.state = state

# probably faster and better to use X-Y as key in a dict
# because otherwise we will have X and Y and an i that is the object name/ref.
# not sure we need a class


# We have a dict cellspace = {} containing ref to the right object
# names are iterative, so for 80 x 24 term, we have 1920 objects/cells
# i = 0
# for rows in range
#    for cols in range
#      i += 1
#      cell_i.state
# 
# #  ## # # # # # # # # #  # #   

# >>> val = ['lol','en','tre'] # list (indexed)
# >>> for i in range(0,3):
#      	print(val[i])
# 
# 	
# lol
# en
# tre
# Note: lists are iterable. Just use 'for i in val' instead


def spawn_map(screen):
    # Creates fresh map (overwrites existing) in zompy_map dict using x,y tuple as key
    # uses a list (x,y) as key. but it's better than translating to/from strings all the time
    xmax = zompy_settings['width']
    ymax = zompy_settings['height']
    
    # clear any previous map (bugfix)
    zompy_map.clear()
    
    # Begin by adding zombies at N coordinates
    # TODO change modifier to rely on screen dimensions ..
    for limit in range(zompy_settings['zombiesToAdd']*10):
        x = random.randint(0,xmax)
        y = random.randint(0,ymax)
        zompy_map[x,y] = (zompy_settings['intLife'],0)
        zompy_settings['genesisAlive'] += 1 # count undead

    # Fill in the blanks with "dead" cells (Conway)
    for x in range(xmax):
        for y in range(ymax):
            zompy_map.setdefault((x,y), (zompy_settings['intDead'],0))
            
#            try:
#                zompy_map[x,y]
#            except KeyError:
#                zompy_map[x,y] = zompy_settings['intDead']
#                zompy_settings['genesisDead'] += 1 # count dead
    

def draw_map(mapscreen):
    # Draws the map saved in zompy_map dict
    # For dimensions, draw chars (note: curses start at 0,0 and not 1,1 like our dict) # TODO
    
    # debug
#    mapscreen.addstr(0,0, 'function draw_map(mapscreen) executed') # debug
#    debug_char = mapscreen.getch() # debug
    
    for y in range(0,zompy_settings['height']):
        for x in range(0,zompy_settings['width']):
            if zompy_map[x,y] == zompy_settings['intBorn']:
                draw_char = zompy_settings['chBorn']
                draw_color = 3
            elif zompy_map[x,y] == zompy_settings['intLife']:
                draw_char = zompy_settings['chLife']
                draw_color = 2
            else:
                draw_char = zompy_settings['chDead'] # Draw dead in else statement to over-write "ghosts"
                draw_color = 1
                
            # execute addstr
            if zompy_settings['color']:
                mapscreen.attron(curses.color_pair(draw_color))
                mapscreen.addstr(y, x, draw_char)
                mapscreen.attroff(curses.color_pair(draw_color))
            else:
                mapscreen.addstr(y, x, draw_char)

def check_collision(input_snake):
    # Checks whether any zombies have eaten the snake specified
    # Changes input_snake.collision_detected to True if that is the case
    for block in range(0,input_snake.length()):
        if zompy_map[input_snake.body[block]] > zompy_settings['intDead']:
            # TODO: check what type of item it is, we can perhaps eat some..?
            if snake.damage(input_snake) > 0:
                input_snake.collision = False
            else:
                input_snake.collision = True
            break # No need to continue loop
    return input_snake.collision


def update_map(input_snake_1, input_snake_2):
    # Updates existing map, raise alert if there's an attack (zombie eating snake)
    # So really, it's more like "opponent's move", rather than map update
    # Legend: anything greater than 0 is occupied space
    coAlive, coBirth, coDead, coControl = conway(zompy_settings['width'],zompy_settings['height'])

    
    # Check collision
    # Allows us to do this for >1 snake later on
    # TODO allow for check of input_nake_2
    
    if not check_collision(input_snake_1):
        # If we (zombies) are not attacking the snake, check stability
        # See if we've reached Conway's GOL Stability Plateau
        zompy_settings['stabilityIs'] = str(coAlive) + '-' + str(coBirth) + '-' + str(coDead)
        if zompy_settings['stabilityIs'] == zompy_settings['stabilityWas']:
            zompy_settings['stabilityRecord'] += 1
        elif zompy_settings['stabilityIs'] == zompy_settings['stabilityBefore']:
            zompy_settings['stabilityRecord'] += 1
        else :
            zompy_settings['stabilityRecord'] = 0
        
        # Save two-step history
        zompy_settings['stabilityBefore'] = zompy_settings['stabilityWas']
        zompy_settings['stabilityWas'] = zompy_settings['stabilityIs']
        

        # if too stable, shake things up a bit
        if zompy_settings['stabilityRecord'] > zompy_settings['stabilityThreshold']:
            front_of_snake = [] # risky zones list. [0] is x [1] is y, index + 2 for 2nd snake
            
            for check_snake in input_snake_1, input_snake_2:
                if check_snake is None: break
                
                # get x,y and direction
                snake_x, snake_y, snake_d = snake.where(check_snake)
                
                if snake_d == 1 or snake_d == 3: # up/down
                    front_of_snake.append(snake_x) # set x
                    if snake_d == 2: # calc y
                        front_of_snake.append(snake_y + 1)
                    else:
                        front_of_snake.append(snake_y - 1)
                else:
                    if snake_d == 2: # going east
                        front_of_snake.append(snake_x+1)
                    else:
                        front_of_snake.append(snake_x-1)
                    
                    front_of_snake.append(snake_y)# unchanged
            
            for z in range(zompy_settings['zombiesToAdd']):
                while True:
                    ypos = random.randint(0,zompy_settings['height'])
                    xpos = random.randint(0,zompy_settings['width'])

                    # See if the zone is empty (required)
                    if zompy_map.setdefault((xpos,ypos), zompy_settings['intDead']) == zompy_settings['intDead']: # bugfix. later resolved in spawn_map() by using dict.clear()
                        
                        # Must make sure to avoid placing obstacle right in front of snake
                        # We can use these from snake class:  self.x, self.y, self.dir
                        if (xpos, ypos) != (front_of_snake[0], front_of_snake[1]):
                            if zompy_settings['singleplayer']:
                                zompy_map[xpos,ypos] = zompy_settings['intBorn'] # So romantic
                                break
                            elif input_snake_2 is not None:
                                if (xpos, ypos) != (front_of_snake[2], front_of_snake[3]):
                                    zompy_map[xpos,ypos] = zompy_settings['intBorn'] # So romantic
                                    break
    
    # Update stats string (if enabled)
    if zompy_settings['stats']:zompy_settings['stats_str'] = f"gen:{zompy_settings['countGenerations']}  zombies:{coAlive}  spawns:{coBirth}  stability:{zompy_settings['stabilityRecord']}  size:{input_snake_1.size}" # TODO
    
    # debug 
    # output map to local file map.txt for debugging
    with open("debug_map.txt", "w") as LOW_COST_DEBUGGER: print(zompy_map, file=LOW_COST_DEBUGGER)


def conway(xmax, ymax):
    """Evolves cells somewhat according to Conway's game of life rules
    However, instead of a bool, we have 4 categories: dead, born, alive, static
    Static cells remain there until game over. An alive cell becomes static if it survives N rounds.
    Returns 4 counter values to calling function update_map()"""
    # Follows Conway's Game of Life rules, with some additions
    
    # Counters
    countAlive = 0
    countBirth = 0
    countDead = 0
    countControl = 0
    
    for x in range(xmax):
        # Get neighboring coordinates (pt.1)
        leftCoord  = (x-1) % xmax # % WIDTH ensures leftCoord is between 0 and WIDTH-1
        rightCoord = (x+1) % xmax # % is remainder (modulus)

        for y in range(ymax):
            # Get neighboring coordinates (pt.2)
            aboveCoord = (y-1) % ymax
            belowCoord = (y+1) % ymax

            numNeighbors = 0 # counter
            for yval in aboveCoord, y, belowCoord:
                for xval in leftCoord, rightCoord,x:
                    if xval == x and yval == y :
                        continue
                    if zompy_map[xval,yval] == 1:
                        numNeighbors += 1

            # set cell based on conway's rules
            if zompy_map[x,y] > zompy_settings['intDead'] and ( numNeighbors == 2 or numNeighbors == 3 ):
                zompy_map[x,y] = zompy_settings['intLife']
                countAlive += 1
            elif zompy_map[x,y] == zompy_settings['intDead'] and (numNeighbors == 3):
                zompy_map[x,y] = zompy_settings['intBorn'] # BIRTH # re-animate
                countBirth += 1
            else:
                zompy_map[x,y] = zompy_settings['intDead'] # die or stay dead
                countDead += 1
    countControl = countAlive + countBirth + countDead
    return countAlive, countBirth, countDead, countControl


class snake:
    def __init__(self, name, size, is_moving, color):
        self.name = name
        self.size = size
        self.color = color # used to visually distinguish play pieces in 2-player mode # TODO
        self.block = 9608 # UTF-8 decimal
        self.is_moving = is_moving
        self.collision = False # not sure we need this ..
        self.x, self.y, self.dir = self.place_on_map()
        self.head = self.x,self.y
        self.body = {0: self.head} # define val
        for bl in range(1,self.size):
            self.body[bl] = self.head
    
    def __str__(self):
        """ For debugging gameloop """
        return f'Hello! I am a snake named {self.name}, {self.size} blocks long, and collision is {self.collision}'
        
            
    # @ property
    # property(fget=None, fset=None, fdel=None, doc=None)
    # 
    # fget is function to get value of the attribute,
    # fset is function to set value of the attribute,
    # fdel is function to delete the attribute 
    # and doc is a string (like a comment)
    
    # These might not be usable here (just sayin' we're doing an awful lot of logic in the class functions rather than in main loop..)
    # @property
    # def size(self):
        # return self.size

    # @property
    # def size.set(self,value):
        # # Usage:     snek.size = 4
        # if value != self.size:
            # self.size = value
    # @property  
    # def is_moving(self):
        # return self.is_moving
    
    # @property
    # def is_moving.set(self, value):
        # # Usage:    snek.is_moving = False
        # # To be used for convenience outside (in loop)
        # self.is_moving = value
    
    def where(self):
        return self.x, self.y, self.dir
    
    def place_on_map(self):
        # Place snake start position in one of four quadrants
        # Returns X and Y positions of head + direction
        snake_dir = None
        while snake_dir is None:
            snake_ypos = random.randint(0,zompy_settings['height'])
            snake_xpos = random.randint(0,zompy_settings['width'])    
            if zompy_map[snake_xpos,snake_ypos] == zompy_settings['intDead']:
                # Set snake direction (as a rule everything is constantly moving)
                # Whether we actually is moving depends on zompy_settings['movement']
                snake_dir = pseudorand_one_to_four() # 1 = North, 2 = East, 3 = South, 4 = West
        
        # We can now provide X and Y start values for snake head position
        # Snake body and tail bits will be calculated from x, y and dir values
        return snake_xpos, snake_ypos, snake_dir
    
    # 1 = North, 2 = East, 3 = South, 4 = West
        

    def draw(self, mapscreen):
        # Draw snake object on the curses mapscreen screen
        # Legend: self.body[n] = x,y (so reverse xpos and ypos)
        if zompy_settings['color']:
            mapscreen.attron(curses.color_pair(4))
            
#        for bl in range(self.size-2,0,-1):
        for bl in range(0,self.size):
            mapscreen.addstr(self.body[bl][1], self.body[bl][0], zompy_settings['chSnek'])
        
        if zompy_settings['color']:
            mapscreen.attroff(curses.color_pair(4))
    
    def erase(self):
        '''Removes tail bit of self.body by 1 from zompy_map'''
        tail_x, tail_y = self.body[self.size-1]
        if zompy_map[tail_x,tail_y] == ['intSnek']:
            zompy_map[tail_x,tail_y] = zompy_settings['intDead']
    
    def evaluate_direction(self, direction):
        # Evaluates key press to change is_moving to False if direction is opposite of self.dir
        # Does not return anything
        if self.dir == direction:
            self.is_moving = True
        else:
            if (self.dir == 1 and direction == 3) or (self.dir == 3 and direction == 1):
                self.is_moving = False
            elif (self.dir == 2 and direction == 4) or (self.dir == 4 and direction == 2):
                self.is_moving = False
            else:
                self.is_moving = True
                
            self.dir = direction # save changed val
    
    def collision_detected(self):
        # Returns True if it's a collision
        # Checks map for any existing object on the spot
        try:
            if zompy_map[self.head] > 0: return True
        except KeyError:
            debug_message(scr=screen, message=f'Got key error for self.head = \'{self.head}\'')
        return False
    
    def grow(self, many):
        """increase snake size by 1 block and return current size"""
        self.size += many
        return self.size
    
    def damage(self, many):
        """called by TODO
        first, set tail to 0 on map (erase)
        then, decrease by <remover> number of blocks
        return current size
        """
        for rem in range(many): self.erase()
        self.size -= many
        return self.size
#        if self.size > 0 : self.collision_detected = False
    
    def slither_snake(self):
        # This function places tail after body (it slithers)
        if self.is_moving:
            xmax = zompy_settings['width']
            ymax = zompy_settings['height']
            if self.dir == 1: # North (W)
                self.y -= 1
                if self.y < 1:
                    self.y = ymax
            elif self.dir == 2: # East (A)
                self.x += 1
                if self.x > xmax:
                    self.x = 1
            elif self.dir == 3: # South (S)
                self.y += 1
                if self.y > ymax:
                    self.y = 1
            elif self.dir == 4: # West (D)
                self.x -= 1
                if self.x < 1:
                    self.x = xmax
            
            # set new head
            self.head = self.x,self.y
        
        # move tail "-1" relative to head's direction
        # all body parts may be stacked on top of each other (complete halt)
        for bl in range(self.size-1,0,-1):
            # Set old map area vacant
            xpos, ypos = self.body[bl]
            zompy_map[xpos,ypos] = zompy_settings['intDead']
            
            # Move block after head
            tail = bl - 1
            self.body[bl] = self.body[tail]
            
            # Set new map area occupied
            xpos, ypos = self.body[tail]
            zompy_map[xpos,ypos] = zompy_settings['intSnek']

        self.body[0] = self.head
    
    
    def length(self):
        ''' returns size of snake in blocks (default: 4 or zompy_settings['blocks'])'''
        return self.size
            
    def update_positions(self, direction):
    # Call using snek.update_positions(n) # where n == 1 = North, 2 = East, 3 = South, 4 = West
        
        if zompy_settings['key_press']:
            self.evaluate_direction(direction) # saves direction to self.dir
        self.slither_snake()
        if self.is_moving:
            if self.collision_detected(): # snek ded # TODO diminish
                self.collision = True
                # set "game over" in main loop


def set_game_defaults():
    # set default config (does not write to file)
    # ALL ACCEPTED VALUES MUST BE SET, otherwise config sanity checks will fail

    # HARD CODED VALUES
    # Map area vacancy classifiers
    zompy_settings['intDead'] = 0
    zompy_settings['intLife'] = 1
    zompy_settings['intBorn'] = 2
    zompy_settings['intSnek'] = -1 # must be less than dead to allow >0 comparisons (faster).
    
    # If true = show startup animation
    zompy_settings['welcome'] = False
    
    # Debug settings (verbose prints of loop mechanics etc.)
    # Toggle ON/OFF by entering 'p' in settings menu
    # (Using try/except to avoid overwriting)
    try:
        zompy_settings['debug']
    except KeyError:
        zompy_settings['debug'] = False
    
    
    # Score for highscore
    zompy_settings['score'] = 0
    zompy_settings['scoreMin'] = 0
    zompy_settings['scoreMax'] = 999999999
    
    # Highscore (stores 10 highest scores)
    # Don't overwrite highscore on restoring defaults
    try:
        zompy_settings['highscore']
    except KeyError:
        zompy_settings['highscore'] = [] # init list
    

    # Min/Max limits for settings toggle
    zompy_settings['limitSpeedMin'] = 0.01 # fastest
    zompy_settings['limitSpeedMax'] = 10

    zompy_settings['limitZombiesMin'] = 100
    zompy_settings['limitZombiesMax'] = 900

    zompy_settings['limitSizeMin'] = 1
    zompy_settings['limitSizeMax'] = 6

    # set default colors and ASCII chars
    # 0. Black
    # 1. Blue
    # 2. Green
    # 3. Cyan
    # 4. Red
    # 5. Magenta
    # 6. Brown
    # 7. White ("Light Gray")
    # 8. Bright Black ("Gray")
    # 9. Bright Blue
    # 10. Bright Green
    # 11. Bright Cyan
    # 12. Bright Red
    # 13. Bright Magenta
    # 14. Yellow
    # 15. Bright White 
    zompy_settings['colorBack'] = 0
    zompy_settings['colorLife'] = 1
    zompy_settings['colorBorn'] = 3
    zompy_settings['colorSnek'] = 2
    zompy_settings['colorDead'] = zompy_settings['colorBack']
    zompy_settings['colorNice'] = 6
    zompy_settings['colorOne'] = zompy_settings['colorSnek']
    zompy_settings['colorTwo'] = zompy_settings['colorNice']
    
    # Booleans and operators for loop control
    zompy_settings['player_has_moved'] = False # obsolete
    zompy_settings['key_press'] = False # bool = key was pressed or not
    zompy_settings['uinput'] = ''       # str = what key was pressed
    zompy_settings['actionOnStable'] = 'exit' # currently not in use, obsolete
    

    # USER-CHANGEABLE VALUES
    # Toggle two-player multiplayer
    zompy_settings['singleplayer'] = True

    # Get terminal size
    set_terminal_size() # sets zompy_settings['width'] and zompy_settings['height']    
    
    # User-changeable settings
    zompy_settings['speed'] = 400 # milliseconds can be related to a "difficult level"
    zompy_settings['genesisDead'] = 0         # TODO stats
    zompy_settings['genesisAlive'] = 0        # TODO stats
    zompy_settings['countStable'] = 0         # TODO stats
    zompy_settings['countGenerations'] = 0    # TODO stats
    zompy_settings['color'] = True
    zompy_settings['style'] = 'blocks'  # default to UTF-8 blocks (blocks/unicode/ascii)
    zompy_settings['reset'] = True      # reset game on set defaults (on window re-size)
    zompy_settings['movement'] = False   # set to False to give user a break (start at rest)
    zompy_settings['reset_on_termchange'] = True # default: reset game if user changes terminal size
    zompy_settings['stats'] = False # show stats overlay (default: off)
    zompy_settings['stats_str'] = None
    zompy_settings['blocks'] = 4        # can also be related to "difficulty level"

    # Conway Stability Plateau workaround
    zompy_settings['stabilityThreshold'] = 18  # can also be related to "difficulty level" z
    zompy_settings['stabilityThreshold'] = 9
    
    zompy_settings['stabilityRecord'] = 0
    zompy_settings['stabilityIs'] = ''
    zompy_settings['stabilityWas'] = ''
    zompy_settings['stabilityBefore'] = ''
    zompy_settings['zombiesToAdd'] = 300  # can also be related to "difficulty level" 
    
    
    # Setting fallback snek symbols (overridden by set_zompy_visuals)
    zompy_settings['chLife'] = None
    zompy_settings['chDead'] = None
    zompy_settings['chBorn'] = None
    zompy_settings['chSnek'] = None

    # Remember to activate visual style (requires curses object)

def set_zompy_visuals(style, color):
    # Ref unicode symbols: https://www.w3schools.com/charsets/ref_utf_block.asp
    # Roughly: If blocks is chosen, we just use background color
    if style == 'blocks' and color == True: # i.e. blocks
        zompy_settings['chLife'] = ' ' # use color N bkg (TODO)
        zompy_settings['chDead'] = ' ' # use transparent bkg
        zompy_settings['chBorn'] = ' ' # use color N-1 bkg (TODO)
        zompy_settings['chSnek'] = ' ' # use green bkg as symbol
    elif style == 'blocks' and color == False: # i.e. unicode
        zompy_settings['color'] = True # use color where available
        zompy_settings['chLife'] = chr(9632)
        zompy_settings['chDead'] = ' ' # empty space
        zompy_settings['chBorn'] = chr(9633)
        zompy_settings['chSnek'] = chr(9608)
    elif style == 'ascii':
        zompy_settings['chLife'] = 'o'
        zompy_settings['chDead'] = ' '
        zompy_settings['chBorn'] = '.'
        zompy_settings['chSnek'] = '#'
    else:
        die(err_code=2)

    if zompy_settings['color']:
        # follows zompy_settings['intType'] above (+1, curses color pairs start at 1)
        # intDead = 0, so color pair is 0 + 1 == 1
        # intLife = 1, so color pair is 2 etc.
        # id  # foreground,        # background
        curses.init_pair(1, -1, zompy_settings['colorDead']) # dead or empty
        curses.init_pair(2, -1, zompy_settings['colorLife']) # life
        curses.init_pair(3, -1, zompy_settings['colorBorn']) # born
        curses.init_pair(4, -1, zompy_settings['colorSnek']) # snake
        #curses.init_pair(5, 0, 10) # titles are black on yellow background
        curses.init_pair(5, curses.COLOR_BLACK, curses.COLOR_YELLOW) # titles are black on yellow background
        curses.init_pair(8, curses.COLOR_YELLOW, -1) # titles are black on yellow background

        # Foreground pairs
        curses.init_pair(6, curses.COLOR_RED, -1)   # red foreground
        curses.init_pair(7, curses.COLOR_GREEN, -1) # green foreground

        # black text on green bkg
        curses.init_pair(9, curses.COLOR_BLACK, curses.COLOR_GREEN)
        
        # 0. Black
        # 1. Blue
        # 2. Green
        # 3. Cyan
        # 4. Red
        # 5. Magenta
        # 6. Brown
        # 7. White ("Light Gray")
        # 8. Bright Black ("Gray")
        # 9. Bright Blue
        # 10. Bright Green
        # 11. Bright Cyan
        # 12. Bright Red
        # 13. Bright Magenta
        # 14. Yellow
        # 15. Bright White 


#def print_in(screen, attr, xpos, ypos):
    # cuts 3 lines down to 1 in code block
    
    # set attribute on
    # mvaddstr
    # set attribute off
    
    # print_in(screen, attribute, xpos, ypos, string)

def set_font(screen, attr, toggle_on):
    # Short hand markup language like toggle (for curses)
    if attr == 'b':
        screen.attron(curses.A_BOLD) if toggle_on else screen.attroff(curses.A_BOLD)
    elif attr == 'u':
        screen.attron(curses.A_UNDERLINE) if toggle_on else screen.attroff(curses.A_UNDERLINE)
    elif attr == 'i':
        screen.attron(curses.A_ITALIC) if toggle_on else screen.attroff(curses.A_ITALIC)
    elif attr == 'blink':
        screen.attron(curses.A_BLINK) if toggle_on else screen.attroff(curses.A_BLINK)
    elif attr == 'rev':
        screen.attron(curses.A_REVERSE) if toggle_on else screen.attroff(curses.A_REVERSE)
    elif attr == 'greenbkg':
        screen.attron(curses.color_pair(9)) if toggle_on else screen.attroff(curses.color_pair(9))
    elif attr == 'green':
        # green foreground color
        screen.attron(curses.color_pair(7)) if toggle_on else screen.attroff(curses.color_pair(7))
    elif attr == 'red':
        # red foreground color
        screen.attron(curses.color_pair(6)) if toggle_on else screen.attroff(curses.color_pair(6))
    elif attr == 'yellow':
        screen.attron(curses.color_pair(8)) if toggle_on else screen.attroff(curses.color_pair(8))
    elif attr == 'title':
        if toggle_on:
            set_font(screen, 'i', True)
            set_font(screen, 'b', True)
            if zompy_settings['color']:
                screen.attron(curses.color_pair(5))
            else:
                set_font(screen, 'rev', True)
        else:
            if zompy_settings['color']:
                screen.attroff(curses.color_pair(5))
            else:
                set_font(screen, 'rev', False)
            set_font(screen, 'b', False)
            set_font(screen, 'i', False)
    elif attr == 'subtitle': # currently not in use..
        if toggle_on:
            set_font(screen, 'title', True)
            set_font(screen, 'i', False)
            set_font(screen, 'greenbkg', True)
        else:
            set_font(screen, 'title', False)
            set_font(screen, 'greenbkg', False)
            


def screen_animation(screen, width, height):
    # Start-up "animation"
    if zompy_settings['color']:
        if zompy_settings['welcome']:
            sleepyt = 0.01
        else:
            sleepyt = 0
        set_font(screen, 'green', True)
        draw_char = ' '
        
        ypos_1 = height - 2
        ypos_2 = height - 5
    
        for xpos in range(0, (width - (width//6))):
            screen.addstr(ypos_1, xpos, chr(9604))
            time.sleep(sleepyt)
            screen.refresh()

        xpos = width - (width//6)
        set_font(screen, 'green', False)

        screen.attron(curses.color_pair(4)) # snake green bkg block
        
        for ypos in range(ypos_1, ypos_2, -1):
            screen.addstr(ypos, xpos, draw_char)
            time.sleep(sleepyt)
            screen.refresh()
        
        screen.attroff(curses.color_pair(4)) # snake green bkg block
        set_font(screen, 'green', True)
        
        while xpos < width:
            screen.addstr(ypos_2, xpos, chr(9604))
            xpos += 1
            time.sleep(sleepyt)
            screen.refresh()
        
        screen.attroff(curses.color_pair(4)) # green off
        set_font(screen, 'green', False)


def screen_welcome(screen, width, height):
    # Draw a friendly welcome screen/home menu
    # Executed from within gameloop function (but outside the loop)
    
    # Draw header
    # subtitle_str = 'A Game Created by Sigbj√∏rn Smelror (c) ' + str(time.localtime()[0])
    byline = 'by Sigbj√∏rn Smelror (c) ' + str(time.localtime()[0])
    draw_header(screen, byline)
    
    # Draw snake logo
    # 24 wide and 6 chars tall
    xcorner = (width // 2) - 12
    ycorner = (height // 2) - 3
    draw_logo(screen, xcorner, ycorner)
    
    # Add Z animation
    screen_animation(screen, width, height)
    
    # Press any key to continue
    press_any_key(screen, width, height)
    
    # Disable further welcomings
    zompy_settings['welcome'] = False


def return_opposite(bool_settings_val):
    if bool_settings_val == 0:
        return 1
    elif bool_settings_val == 1:
        return 0

def toggle_debug(screen, width):
    # ON/OFF toggle debug (press p or P in menu or quick menu)
    screen.addstr(2,width-10, 'DEBUG')
    if zompy_settings['debug']:
        zompy_settings['debug'] = False
        screen.addstr(3,width-15, 'debug disabled')
    else:
        zompy_settings['debug'] = True
        screen.addstr(3,width-14, 'debug enabled')
    screen.refresh()
    time.sleep(1)

def debug_message(**kwargs):
    # Get args (debug msgs and screen)
    message_1 = kwargs.get('msg', ' ')
    message_2 = kwargs.get('msg2', ' ')
    scr = kwargs.get('scr', 0)
    if scr is 0:
        die(err_code=9)
    scr.addstr(0,0,message_1)
    scr.addstr(1,0,message_2)
    scr.addstr(2,0,'PAUSED')
    scr.getch()

def screen_settings(screen):
    # Let user choose/toggle settings with arrow keys and ENTER
    # Executed from within gameloop function (but outside the actual loop)

    # menu structure
    smenu = zompy_chsetmenu

    width, height = get_terminal_size()
    first_column = 4
    second_column = ((width // 3) // 2)-1
    third_column = width // 2
    
    
    '''
    Settings
        Difficulty level           EASY / MEDIUM / HARD / CUSTOM
        Speed (seconds)            0.4
        Initial Snake Size         4
        Zombies to add             10
    
    
    Gameplay
        Two-Player Mode              ON / OFF
        Start in motion              ON / OFF
        Reset on terminal resize     ON / OFF
    
    
    Visual
        Stats overlay                ON / OFF
        Style                        COLOR BLOCKS / UNICODE / ASCII
        
        
        [S]ave and continue / [C]ancel / [R]eset to defaults
    '''
    # inner drawing function
    def draw_smenu(selected_row):
        # Draws the menu with current selection and active settings
        # Legend                0              1                  2                     3                    4           5     6      7              8                    9                   10               11   12     13         14               15
        # zompy_chsetmenu = ['Settings', 'Difficulty level', 'Speed (seconds)', 'Initial Snake Size', 'Zombies to add', ' ', ' ', 'Gameplay' , 'Two-Player Mode', 'Start in motion', 'Reset on terminal size', ' ', ' ', 'Visual', 'Stats overlay', 'Style']
          
        # geometry
        for idx, row in enumerate(smenu):
            if row == ' ': # skip spacing items
                continue
            ypos = height // 2 - len(smenu) // 2 + idx
            
            if row == 'Settings' or row == 'Gameplay' or row == 'Visual':
                # meta menu
                xpos = first_column
                screen.addstr(ypos, xpos, row)
            else:
                # setting titles
                xpos = second_column
                screen.addstr(ypos, xpos, row)
                
                # actual settings toggle
                xpos = third_column
                
                # mark selected
                if idx == selected_row:
                    set_font(screen, 'rev', True)
                
                # This is dense
                if idx == 1:
                    if user_set_difficulty == 0:
                        set_font(screen, 'u', True)
                        screen.addstr(ypos, xpos, 'EASY')
                        set_font(screen, 'u', False)
                        xpos += len('EASY')
                        screen.addstr(ypos, xpos, ' / MEDIUM / HARD / CUSTOM')
                    elif user_set_difficulty == 1:
                        screen.addstr(ypos, xpos, 'EASY / ')
                        xpos += len('EASY / ')
                        set_font(screen, 'u', True)
                        screen.addstr(ypos, xpos, 'MEDIUM')
                        set_font(screen, 'u', False)
                        xpos += len('MEDIUM')
                        screen.addstr(ypos, xpos, ' / HARD / CUSTOM')
                    elif user_set_difficulty == 2:
                        screen.addstr(ypos, xpos, 'EASY / MEDIUM / ')
                        xpos += len('EASY / MEDIUM / ')
                        set_font(screen, 'u', True)
                        screen.addstr(ypos, xpos, 'HARD')
                        set_font(screen, 'u', False)
                        xpos += len('HARD')
                        screen.addstr(ypos, xpos, ' / CUSTOM')
                    else:
                        screen.addstr(ypos, xpos, 'EASY / MEDIUM / HARD / ')
                        xpos += len('EASY / MEDIUM / HARD / ')
                        set_font(screen, 'u', True)
                        screen.addstr(ypos, xpos, 'CUSTOM')
                        set_font(screen, 'u', False)
                elif idx > 1 and idx < 5:
                    if idx == 2:
                        user_setting_i = user_set_speed
                    elif idx == 3:
                        user_setting_i = user_set_size
                    elif idx == 4:
                        user_setting_i = user_set_zombies
                    screen.addstr(ypos, xpos, str(user_setting_i))
                elif idx > 7 and idx < 15:
                    if idx == 8:
                        user_setting_i = user_set_multiplay
                    elif idx == 9:
                        user_setting_i = user_set_startmove
                    elif idx == 10:
                        user_setting_i = user_set_termresize
                    else:
                        user_setting_i = user_set_showstat

                    if user_setting_i == 1:
                        set_font(screen, 'u', True)
                        screen.addstr(ypos, xpos, 'ON')
                        set_font(screen, 'u', False)
                        xpos += len('ON')
                        screen.addstr(ypos, xpos, ' / OFF')
                    else:
                        screen.addstr(ypos, xpos, 'ON / ')
                        xpos += len('ON / ')
                        set_font(screen, 'u', True)
                        screen.addstr(ypos, xpos, 'OFF')
                        set_font(screen, 'u', False)
                else:
                    # style block
                    if user_set_style == 0:
                        set_font(screen, 'u', True)
                        screen.addstr(ypos, xpos, 'COLOR BLOCKS')
                        set_font(screen, 'u', False)
                        xpos += len('COLOR BLOCKS')
                        screen.addstr(ypos, xpos, ' / UNICODE / ASCII')
                    elif user_set_style == 1:
                        screen.addstr(ypos, xpos, 'COLOR BLOCKS / ')
                        xpos += len('COLOR BLOCKS / ')
                        set_font(screen, 'u', True)
                        screen.addstr(ypos, xpos, 'UNICODE')
                        set_font(screen, 'u', False)
                        xpos += len('UNICODE')
                        screen.addstr(ypos, xpos, ' / ASCII')
                    else:
                        screen.addstr(ypos, xpos, 'COLOR BLOCKS / UNICODE / ')
                        xpos += len('COLOR BLOCKS / UNICODE / ')
                        set_font(screen, 'u', True)
                        screen.addstr(ypos, xpos, 'ASCII')
                        set_font(screen, 'u', False)
                    
                    # turn off attributes
                    if idx == selected_row:
                        set_font(screen, 'rev', False)
                            
                    # final round paints
                    bottom_thang = '[S]ave and continue / [C]ancel / [R]eset to defaults'
                    ypos += 3
                    xpos = (width // 2) - (len(bottom_thang) // 2)
                    screen.addstr(ypos, xpos, bottom_thang)
                    
                    bottom_thang_2 = 'Select and hit [ENTER] to toggle'
                    ypos -= 1
                    xpos = (width // 2) - (len(bottom_thang_2) // 2)
                    
                    screen.addstr(ypos, xpos, bottom_thang_2)
                                   
                if idx == selected_row:
                    set_font(screen, 'rev', False) # failsafe?

        # Draw canvas and menu
        screen.refresh()
        
    # End of inner func
    
    
    # Initiate local vars
    # Used as a go-between so that the user can Cancel without changing anything
    user_set_speed = zompy_settings['speed'] / 1000
    user_set_size = zompy_settings['blocks']
    user_set_zombies = zompy_settings['zombiesToAdd']
    
    if zompy_settings['singleplayer']:
        user_set_multiplay = 0
    else:
        user_set_multiplay = 1
    
    if zompy_settings['movement']:
        user_set_startmove = 1
    else:
        user_set_startmove = 0
        
    if zompy_settings['reset_on_termchange']:
        user_set_termresize = 1
    else:
        user_set_termresize = 0
    
    if zompy_settings['stats']:
        user_set_showstat = 1
    else:
        user_set_showstat = 0
    
    if zompy_settings['style'] == 'blocks':
        if zompy_settings['color']:
            user_set_style = 0
        else:
            user_set_style = 1
    else:
        user_set_style = 2
    
    
    user_set_option = None # action option (save/reset/cancel)
    user_set_selected = 1  # line selected
    

    # Menu loop
    while user_set_option is None:
        draw_header(screen, 'Settings')
        
        if user_set_speed == 0.4 and user_set_zombies == 10 and user_set_size == 4:
            user_set_difficulty = 1 # medium
        elif user_set_speed > 0.4 and user_set_zombies < 10 and user_set_size >= 4:
            user_set_difficulty = 0 # easy
        elif user_set_speed < 0.4 and user_set_zombies > 10 and user_set_size < 4:
            user_set_difficulty = 2 # hard
        else:
            user_set_difficulty = 3 # custom
  
        # Draw the header + menu onto screen (including refresh)
        draw_smenu(user_set_selected)
        
        # Get uinput
        try:
            key = screen.getch()
        except KeyboardInterrupt:
            user_set_option = 'Cancel' # break
        except:
            user_set_option = 'Cancel' # break
            
        check_key = get_wasd_input(key) # 1 up/W, 2 left/A, 3 down/S, 4 right/D or 0 (examine key further)
        
        # Analyze uinput
        if check_key == 1 and user_set_selected > 0:
            user_set_selected -= 1
            while smenu[user_set_selected] == ' ' or smenu[user_set_selected] == 'Settings' or smenu[user_set_selected] == 'Gameplay' or smenu[user_set_selected] == 'Visual':
                user_set_selected -= 1
        elif check_key == 3:
            if key != curses.KEY_DOWN:
                # choice == S => save menu
                user_set_option = 'Save' # break
            elif user_set_selected < len(smenu)-1:            
                user_set_selected += 1
                while smenu[user_set_selected] == ' ' or smenu[user_set_selected] == 'Settings' or smenu[user_set_selected] == 'Gameplay' or smenu[user_set_selected] == 'Visual':
                    user_set_selected += 1
        elif key == 99 or key == 67 or key == 27: # c/C or Esc
            user_set_option = 'Cancel' # break
        elif key == 114 or key == 82: # r or R
            user_set_option = 'Reset' # break
        elif key == 80 or key == 112:
            toggle_debug(screen, width)
        elif key == curses.KEY_ENTER or key in [10,13]: # Change settings
            if smenu[user_set_selected].lower() == 'two-player mode':
                user_set_multiplay = return_opposite(user_set_multiplay)  # toggle on/off
            elif smenu[user_set_selected].lower() == 'start in motion': 
                user_set_startmove = return_opposite(user_set_startmove)
            elif smenu[user_set_selected].lower() == 'reset on terminal size':
                user_set_termresize = return_opposite(user_set_termresize)
            elif smenu[user_set_selected].lower() == 'stats overlay':
                user_set_showstat = return_opposite(user_set_showstat)
            elif smenu[user_set_selected].lower() == 'difficulty level':
                # cycle between menu items
                if user_set_difficulty < 2:
                    user_set_difficulty += 1
                else:
                    user_set_difficulty = 0
                
                # Use pre-sets for easy, medium (default), hard
                # These are kind of arbitrary, but does not matter (expected usage: medium or custom)
                if user_set_difficulty == 0:
                    user_set_speed = 1
                    user_set_zombies = 3
                    user_set_size = 5
                elif user_set_difficulty == 1:
                    user_set_speed = 0.4
                    user_set_zombies = 10
                    user_set_size = 4
                elif user_set_difficulty == 2:
                    user_set_speed = 0.2
                    user_set_zombies = 14
                    user_set_size = 2
            elif smenu[user_set_selected].lower() == 'style':
                # cycle between options
                if user_set_style < 2:
                    user_set_style += 1
                else:
                    user_set_style = 0
            #elif smenu[user_set_selected].lower() == 'speed' or smenu[user_set_selected].lower() == 'initial snake size' or smenu[user_set_selected].lower() == 'zombies to add': # TODO use else here?
            else: # avoid relying too much on menu item strings
                # allow human input (sigh)
                
                # save fallback value
                val_to_change = smenu[user_set_selected].lower()
                
                # set distinctions
                if val_to_change == 'speed (seconds)':
                    val_is_float = True
                    val_toch_min = zompy_settings['limitSpeedMin']
                    val_toch_max = zompy_settings['limitSpeedMax']
                else:
                    val_is_float = False
                    if val_to_change == 'zombies to add':
                        val_toch_min = zompy_settings['limitZombiesMin']
                        val_toch_max = zompy_settings['limitZombiesMax']
                    else:
                        val_toch_min = zompy_settings['limitSizeMin']
                        val_toch_max = zompy_settings['limitSizeMax']
                mmenustr = f'{val_to_change.upper()} ({val_toch_min}-{val_toch_max})' # popup title
                val_var_len = len(mmenustr) # for canvas' area calc

                # user input mini input
                # Create empty canvas in center of screen
                # Requires 5 lines height and val_var_len + 2 width
                
                # ''''''''''''''''''''''''''#
                # HEADER
                # 
                # VALUE:                    
                # __________________________#
                
                
                # Empty canvas                
                canvas_y_beg = (height // 2) - 5
                canvas_y_end = canvas_y_beg + 5
                canvas_x_beg = width // 2 - ((val_var_len//2) + 3)
                canvas_x_end = canvas_x_beg + (val_var_len + 3)
                
                draw_popup(screen, canvas_y_beg, canvas_x_beg, canvas_y_end, canvas_x_end, False)
                
                # Add prompter to popup
                xpos = canvas_x_beg + 1
                ypos = canvas_y_beg + 1

                screen.addstr(ypos, xpos + 1, mmenustr) # xpos + 1 for side padding
                ypos += 2
                mmenustr = 'Change to'
                screen.addstr(ypos, xpos + 1, str(mmenustr+': '))
                allow_input(screen, True)
                screen.refresh()
                
                # Get input
                mmenu_uinput =''
                while True:
                    char = screen.getch()
                    if char == curses.KEY_ENTER or char in [10, 13] or char == 27:
                        break
                    else:
                        try:
                            char = chr(int(char))
                            mmenu_uinput += str(char)
                        except ValueError:
                            pass
                        except KeyboardInterrupt:
                            mmenu_uinput = None
                            break

                # remove cursor again
                allow_input(screen, False)                
                
#                screen.addstr(0,0, str(type(mmenu_uinput))) # debug
#                mmenu_uinput = int(mmenu_uinput)# debug
                
                # Weak input validation (just set to None type if fail)
                if val_is_float:
                    try:
                        mmenu_uinput = float(mmenu_uinput)
                    except:
                        mmenu_uinput = None
                else:
                    try:
                        mmenu_uinput = int(mmenu_uinput)
                    except:
                        mmenu_uinput = None
                
#                screen.addstr(1,0, str(type(mmenu_uinput))) # debug
#                screen.addstr(1,18,str(mmenu_uinput))
#                char = screen.getch() # debug
                
                # Save temp value to the right variable (if it passed inspection)
                if mmenu_uinput is not None:
                    if mmenu_uinput >= val_toch_min and mmenu_uinput <= val_toch_max:
                        if val_to_change == 'speed (seconds)':
                            user_set_speed = mmenu_uinput
                        elif val_to_change == 'zombies to add':
                            user_set_zombies = mmenu_uinput
                        else:
                            user_set_size = mmenu_uinput
                
                
#                screen.addstr(2,0, str(val_to_change)) # debug
#                screen.addstr(3,0, str(zompy_settings['limitSizeMin'])) # debug
#                screen.addstr(4,0, str(zompy_settings['limitSizeMax'])) # debug
#                screen.addstr(5,0, str(user_set_size)) # debug
#                char = screen.getch() # debug
#                die(err_code=8)

    # Get menu choices:
    # legend     [S]ave and continue / [C]ancel / [R]eset to defaults
    # Don't do anything on Cancel option
    
#    screen.addstr(4,0, 'user_set_option:') # debug
 #   screen.addstr(5,0, user_set_option) # debug
  #  char = screen.getch() # debug
    
    if user_set_option == 'Save':
        # Overwrite existing settings with the new ones
        
        zompy_settings['speed'] = int(user_set_speed * 1000)
        zompy_settings['blocks'] = user_set_size
        zompy_settings['zombiesToAdd'] = user_set_zombies
        
        if user_set_multiplay == 0:
            zompy_settings['singleplayer'] = True
        else:
            zompy_settings['singleplayer'] = False
        
        if user_set_startmove == 1:
            zompy_settings['movement'] = True
        else:
            zompy_settings['movement'] = False

        if user_set_termresize == 1:
            zompy_settings['reset_on_termchange'] = True
        else:
            zompy_settings['reset_on_termchange'] = False
        
        if user_set_showstat == 1:
            zompy_settings['stats'] = True
        else:
            zompy_settings['stats'] = False

        # Style block (this contains a limitation (no ascii color)) # TODO
        if user_set_style == 0:
            zompy_settings['style'] = 'blocks'
            zompy_settings['color'] = True
        elif user_set_style == 1:
            zompy_settings['style'] = 'blocks' # unicode symbols in black/white
            zompy_settings['color'] = False
        else:
            zompy_settings['style'] = 'ascii'
            zompy_settings['color'] = False
        
    elif user_set_option == 'Reset':
        # Display warning and prompt for confirmation
        warning_label = 'Reset to defaults?'
        
        # Empty canvas                
        canvas_y_beg = (height // 2) - 5
        canvas_y_end = canvas_y_beg + 5
        canvas_x_beg = width // 2 - ((len(warning_label)//2) + 3)
        canvas_x_end = canvas_x_beg + len(warning_label) + 5
        draw_popup(screen, canvas_y_beg, canvas_x_beg, canvas_y_end, canvas_x_end, False)
        
        ypos = canvas_y_beg + 1
        xpos = canvas_x_beg + 2
        mmenustr = warning_label.upper()
        screen.addstr(ypos, xpos + 1, mmenustr) # xpos + 1 for side padding
        ypos += 2
        mmenustr = 'Type \'yes\': '
        screen.addstr(ypos, xpos + 1, mmenustr)
        
        allow_input(screen, True)
        screen.refresh()
        
        mmenu_uinput =''
        while True:
            char = screen.getch()
            if char == curses.KEY_ENTER or char in [10, 13] or char == 27:
                break
            else:
                try:
                    char = chr(int(char))
                    mmenu_uinput += str(char)
                except ValueError:
                    pass
                except KeyboardInterrupt:
                    mmenu_uinput = None
                    break
        
        try:
            if mmenu_uinput.lower() == 'yes':
                reset_to_defaults = True
            else:
                reset_to_defaults = False
        except KeyboardInterrupt:
            reset_to_defaults = False
        except:
            reset_to_defaults = False
        
        allow_input(screen, False) # remove cursor again
        
        # clear mini canvas
        ypos = canvas_y_beg + 3
        xpos = canvas_x_beg + 3
        
        if reset_to_defaults:
            set_game_defaults() # Restore defaults
            warning_label = 'Restoring defaults'
        else:
            warning_label = 'Settings unchanged'     
        
        screen.addstr(ypos, xpos, warning_label) # xpos + 1 for side padding
        screen.refresh()
        char = screen.getch() # press any key ...
            
    # Save configuration to file
    if 'Cancel' not in user_set_option:
        # Save to file
        save_conf(zompy_config_file)
        
        # Activate visual style(s)
        set_zompy_visuals(zompy_settings['style'], zompy_settings['color'])

    # Reset game (must be reset)
    zompy_settings['reset'] = True


def get_wasd_input(key):
    # Takes curses input (key) and determine wasd output (or Unknown = 0)
    # If Two-Player mode, one has arrow keys and the other w,a,s,d

    if key == curses.KEY_UP or key == 119 or key == 87:      # W
        ret_key = 1 # North
    elif key == curses.KEY_LEFT or key == 97 or key == 65:   # A
        ret_key = 4 # East
    elif key == curses.KEY_DOWN or key == 115 or key == 83:  # S
        ret_key = 3 # South
    elif key == curses.KEY_RIGHT or key == 100 or key == 68: # D
        ret_key = 2 # West
    else:
        return 0 # break fast

    if zompy_settings['singleplayer']:
        return ret_key
    elif type(key) is int:
        ret_key += 4 # 2nd player has keys 5, 6, 7, 8 for W, A, S, D
    return ret_key


def draw_popup(screen, from_y, from_x, to_y, to_x, refresh):
    # From_y = top < to_y, from_x < to_x
    # Draws a background of empty spaces with border frame
    # Allows us to put menu "in front of" existing stuff without interfering
    # Refresh only on request (bool).
    
    # Empty space
    for canvas_y in range(from_y, to_y):
        for canvas_x in range(from_x, to_x):
            screen.addstr(canvas_y, canvas_x, ' ')

    if zompy_settings['color']:
        set_font(screen, 'yellow', True)

    # Add corners
    screen.addstr(from_y, from_x, chr(9581)) # top left frame
    screen.addstr(from_y, to_x, chr(9582)) # top right
    screen.addstr(to_y, to_x, chr(9583)) # bottom right
    screen.addstr(to_y, from_x, chr(9584)) # bottom left frame
    
    # Add bars
    for xpos in from_x, to_x:
        for ypos in range(from_y+1, to_y):
            screen.addstr(ypos, xpos, chr(9474)) # vertical
    for ypos in from_y, to_y:
        for xpos in range(from_x + 1, to_x):
            screen.addstr(ypos, xpos, chr(8213)) # horizontal

    if zompy_settings['color']:
        set_font(screen, 'yellow', False)

    
    if refresh:
        screen.refresh()


def draw_quickmenu(screen, selected, width, height, canvas_y_beg, canvas_y_end, canvas_x_beg, canvas_x_end):
    # First draw a background of empty spaces with +2 char padding
    # Instead of clearing the whole screen, fill canvas with spaces
    qmenu = zompy_quickmenu
    
    # Draw empty canvas area
    draw_popup(screen, canvas_y_beg, canvas_x_beg, canvas_y_end, canvas_x_end, False)
    
    # Create regular ascii menu
    for idx, txt in enumerate(qmenu):
        ypos = height//2 - len(qmenu)//2 + idx
        xpos = width//2 - len(txt)//2
        if idx == selected:
            set_font(screen, 'rev', True)
            screen.addstr(ypos, xpos, txt)
            set_font(screen, 'rev', False)
        else:
            screen.addstr(ypos, xpos, txt)

    # Draw canvas and menu
    screen.refresh()


def game_over(screen,  width, height, snake_was_eaten):
    # This is final (i.e. game over)
    # snake_was_eaten bool = True if snake was eaten by zombie, otherwise (user crashed = ) False

    draw_header(screen, 'Game Over')
    
    press_any_key(screen, width, height)
    
    

def screen_quickmenu(screen, width, height):
    # This is the function we call to display a quick menu (within game loop)
    # local shorthand
    qmenu = zompy_quickmenu
    
    # Add penalty
    qmenu_idle_time = epoch_as_sec()
    
    # Define draw area
    canvas_size_x = 0
    for row in qmenu:
        if len(row) > canvas_size_x:
            canvas_size_x = len(row)
    
    canvas_y_beg = (height//2 - len(qmenu)) - 1   # top
    canvas_y_end = (height//2 + len(qmenu)) + 1   # bot
    canvas_x_beg = (width//2 - canvas_size_x) - 1 # left
    canvas_x_end = (width//2 + canvas_size_x) + 1 # right
    
    # Draw menu
    selected_item = 0
    draw_quickmenu(screen, selected_item, width, height, canvas_y_beg, canvas_y_end, canvas_x_beg, canvas_x_end)
    
    while True:
        qmkey = screen.getch()
        if qmkey == curses.KEY_UP and selected_item > 0:
            selected_item -= 1
        elif qmkey == curses.KEY_DOWN and selected_item < len(qmenu)-1:
            selected_item += 1
        elif qmkey == 80 or qmkey == 112:
            toggle_debug(screen, width)
        elif qmkey == curses.KEY_ENTER or qmkey in [10,13]:
            # What did we select
            qmchoice = qmenu[selected_item].lower()
            
            # Act on selection
            # assuming zompy_quickmenu = ['Continue', 'Restart', 'Main Menu', 'Exit']
            if qmchoice == 'continue':
                break
            elif qmchoice == 'toggle stats':
                if zompy_settings['stats']:
                    zompy_settings['stats'] = False
                else:
                    zompy_settings['stats'] = True
                break
            elif qmchoice == 'restart':
                zompy_settings['reset'] = True # abort current game
                break
            elif qmchoice == 'exit':
                zompy_settings['reset'] = True # abort current game
                screen_menu(screen, width, height)
                break
            else:
                # Settings or 'main menu':
                zompy_settings['reset'] = True # abort current game
                screen_settings(screen)
                break
                
        draw_quickmenu(screen, selected_item, width, height, canvas_y_beg, canvas_y_end, canvas_x_beg, canvas_x_end)
        screen.refresh()

    # Upon exit of menu, loop will re-draw on next iteration
    
    # Don't increment the score though (add time spent here == less play time (score reduction))
    zompy_settings['score'] = zompy_settings['score'] + (epoch_as_sec() - qmenu_idle_time)


def draw_header(screen, subtitle_str):
    # Draw the header (2 lines on top)
    # Used in welcome screen, main menu, about and highscore
    
    screen.clear()    
    width, height = get_terminal_size()
    
    # Set main title
    # title_str = "Zompy: Conway's Game of Snakes and Zombies"
    title_str = 'S n e k  ' + chr(9650) +  '  Snake and Adder'
    
    # Enable style (in b/w or color)
    set_font(screen, 'title', True)
    
    # Clear 2 top lines
    for ypos in range(0, 2):
        for xpos in range(0, width):
            screen.addstr(ypos, xpos, ' ')

    # Add title string
    screen.addstr(0, 1, title_str)

    # Add subtitle
    set_font(screen, 'b', False)
    # xpos = width - (len(subtitle_str) + 1)
    xpos = (width // 2) - len(subtitle_str)//2
    screen.addstr(1, xpos, subtitle_str)
    
    # Disable styling
    set_font(screen, 'title', False)
    
    # refresh() run in calling function


#def draw_snake(screen, xcorner, ycorner):
#    # OBSOLETED THIS FUNCTION 
#    # Draws a snake from xcorner, ycorner as top left canvas position
#    # 9 chars wide and 6 chars tall (no padding)
#    slogo_0 = chr(9625) + 3 * chr(9602) + chr(9604) + chr(9605) + chr(9600)
#    slogo_1 = chr(9614) + '     ' + chr(9608)
#    slogo_2 = ' ' + chr(9600) + chr(9604) * 4 + chr(9602)
#    slogo_3 = ' ' + chr(9608) + chr(9620)
#    slogo_4 = ' ' + chr(9601) + chr(9602) *2 + chr(9603) + chr(9605) + chr(9604)
#    slogo_5 = chr(8722) + chr(8826) # tongue
#    slogo_6 = '  ' + chr(9620) * 2 # extra bottom padding
#    ypos = ycorner
#    xpos = xcorner
#    set_font(screen, 'green', True)
#    screen.addstr(ypos, xpos, slogo_4)
#    set_font(screen, 'red', True)
#    xpos = xpos + len(slogo_4)
#    set_font(screen, 'blink', True)
#    screen.addstr(ypos, xpos, slogo_5)
#    set_font(screen, 'blink', False)
#    xpos = xcorner
#    set_font(screen, 'green', True)
#    ypos +=1
#    screen.addstr(ypos, xpos, slogo_3)
#    ypos +=1
#    screen.addstr(ypos, xpos, slogo_2)
#    ypos +=1
#    screen.addstr(ypos, xpos, slogo_1)
#    ypos +=1
#    screen.addstr(ypos, xpos, slogo_0)
#    ypos +=1
#    screen.addstr(ypos, xpos, slogo_6)
#    set_font(screen, 'green', False)


def draw_logo(screen, xcorner, ycorner):
    # Puts our block element snake logo, drawing from top left and downwards (4->0)
    # 24 chars wide and 6 tall
    
    slogo_0 = chr(9625) + 3 * chr(9602) + chr(9604) + chr(9605) + chr(9600)
    slogo_1 = chr(9614) + '     ' + chr(9608)
    slogo_2 = ' ' + chr(9600) + chr(9604) * 4 + chr(9602)
    slogo_3 = ' ' + chr(9627) + chr(9620)
    slogo_4 = ' ' + chr(9601) + chr(9602) *2 + chr(9603) + chr(9605) + chr(9604)
    slogo_5 = chr(8722) + chr(8826) # tongue
    slogo_6 = '  ' + chr(9620) * 2 # extra bottom padding
    
    nlogo_0 = chr(9631) + chr(9614) + ' ' + chr(9608)
    nlogo_1 = chr(9616) + '  ' + chr(9610)
    nlogo_2 = chr(9625) + chr(9602) * 2 + chr(9601)
    
    elogo_0 = chr(9628) + chr(9604) * 2 + chr(9630)
    elogo_1 = chr(9608) + chr(9602) * 2 + chr(9630)
    elogo_2 = chr(9601) + chr(9602) * 2 + chr(9601)

    klogo_0 = chr(9608) + '  ' + chr(9616) + chr(9625) + chr(9622)
    klogo_1 = chr(9616) + chr(9600) + chr(9628) + chr(9625)
    klogo_2 = chr(9616) + chr(9604) + chr(9631)
    klogo_3 = chr(9608) + '  ' + chr(9608)
    
    sublogo = 'Snake and Adder'
    
    # Draw on screen object
    if zompy_settings['color']:
        set_font(screen, 'green', True)

    ypos = ycorner
    xpos_s = xcorner
    
    screen.addstr(ypos, xpos_s, slogo_4)
    
    if zompy_settings['color']:
        set_font(screen, 'red', True)
    
    xpos_s = xpos_s + len(slogo_4)
    set_font(screen, 'blink', True)
    screen.attron(curses.A_BLINK)
    screen.addstr(ypos, xpos_s, slogo_5)
    set_font(screen, 'blink', False)
    xpos_s = xcorner
    
    if zompy_settings['color']:
        set_font(screen, 'green', True)
    
    ypos +=1
    screen.addstr(ypos, xpos_s, slogo_3)
    xpos_k = xpos_s + 18               # calc k x-pos
    screen.addstr(ypos, xpos_k, klogo_3)
    ypos +=1
    screen.addstr(ypos, xpos_s, slogo_2)
    xpos_n = xpos_s + len(slogo_2) + 1 # calc n x-pos
    screen.addstr(ypos, xpos_n, nlogo_2)
    xpos_e = xpos_n + len(nlogo_2) + 1 # calc e x-pos
    screen.addstr(ypos, xpos_e, elogo_2)
    screen.addstr(ypos, xpos_k, klogo_2)
    ypos +=1
    screen.addstr(ypos, xpos_s, slogo_1)
    screen.addstr(ypos, xpos_n, nlogo_1)
    screen.addstr(ypos, xpos_e, elogo_1)
    screen.addstr(ypos, xpos_k, klogo_1)
    ypos +=1
    screen.addstr(ypos, xpos_s, slogo_0)
    screen.addstr(ypos, xpos_n, nlogo_0)
    screen.addstr(ypos, xpos_e, elogo_0)
    screen.addstr(ypos, xpos_k, klogo_0)
    xpos_s -= 1
    screen.addstr(ypos, xpos_s, chr(9621)) # fat tail fix (boo)
    ypos +=1
    screen.addstr(ypos, xpos_s, slogo_6)
    xpos = xpos_s + len(slogo_6) + 2
    
    set_font(screen, 'i', True)
    set_font(screen, 'b', True)
    screen.addstr(ypos, xpos, sublogo) # subtitle
    set_font(screen, 'i', False)
    set_font(screen, 'b', False)
    
    if zompy_settings['color']:
        set_font(screen, 'green', False)
    
    screen.refresh()


def draw_menu(screen, current, width, height):
    # This is the main menu (outside game loop)
    # This probably needs a rewrite / some adjustments .. TODO
    
    # Put a header on top
    draw_header(screen, 'S n e k :: Snake & Adder')
    
    # Window decorations
    # draw_char = zompy_settings['chSnek']
    # if zompy_settings['color']:
        # screen.attron(curses.color_pair(4)) # snake green bkg block
        # if zompy_settings['style'] == 'blocks':
            # screen.attroff(curses.color_pair(4))
            # set_font(screen, 'green', True) # snake green foreground color
            # draw_char = chr(9617)
    # if zompy_settings['style'] == 'ascii':
        # set_font(screen, 'b', True)
    # ypos = height - 4
    # for xpos in range(0, width//5):
        # screen.addstr(ypos, xpos, draw_char)
    # for ypos in range(ypos, ypos - (height//2)):
        # screen.addstr(ypos, xpos, draw_char)
    # for xpos in range(xpos, width + 1):
        # screen.addstr(ypos, xpos, draw_char)
    # if zompy_settings['style'] == 'ascii':
        # set_font(screen, 'b', False)
    # if zompy_settings['color']:
        # screen.attroff(curses.color_pair(4))
        # if zompy_settings['style'] == 'blocks':
            # set_font(screen, 'green', False)
    
    # Put game snake logo on left hand side
    # TODO requires adjustment
    draw_logo(screen, (width // 10) + 2, ( height // 2 ) - 3)


    # Add Z animation
    screen_animation(screen, width, height)

    # Find widest text in menu (necessary)
    txtwidth = 0
    for idx, mtext in enumerate(zompy_main_menu):
        if len(mtext) > txtwidth:
            txtwidth = len(mtext)
    
    # Put curses menu on right hand side
    xpos = (( width // 3 ) * 2) - 3
    ypos = ( height // 2 ) - len(zompy_main_menu) + 4
    
    
    # draw menu decor
    from_y = ypos - 2
    to_y = ypos + len(zompy_main_menu) + 1
    from_x = xpos - 2
    to_x = xpos + txtwidth + 3
    draw_popup(screen, from_y, from_x, to_y, to_x, False)    
    
    # Draw menu
    for idx, mtext in enumerate(zompy_main_menu):
        if idx == current:
            set_font(screen, 'rev', True)
            screen.addstr(ypos, xpos, mtext)
            set_font(screen, 'rev', False)
        else:
            screen.addstr(ypos, xpos, mtext)
        ypos += 1
 



def screen_menu(screen, width, height):
    # This is the game's main menu
    mmenu = zompy_main_menu # Shorthand
    mcurrent = 0
    
    while True:
        draw_menu(screen, mcurrent, width, height)
        
        try:
            mmkey = screen.getch()            
            chkkey = get_wasd_input(mmkey)
            if chkkey == 1 and mcurrent > 0:
                mcurrent -= 1
                if mmenu[mcurrent] == ' ':
                    mcurrent -= 1
            elif chkkey == 3 and mcurrent < len(mmenu)-1:
                mcurrent += 1
                if mmenu[mcurrent] == ' ':
                    mcurrent += 1
            elif mmkey == 80 or mmkey == 112: # press P to enable debug mode
                toggle_debug(screen,width)
            elif mmkey == 27: # ESC
                raise SystemExit
            elif mmkey == curses.KEY_ENTER or mmkey in [10,13]:
                m_item = mmenu[mcurrent]
                if m_item == 'Play':
                    status_message(screen, width, height, 'Loading ..')
                    break
                elif m_item == 'Settings':
                    screen_settings(screen)
                elif m_item == 'Highscores':
                    screen_highscore(screen, 0, 0, width, height) # with 0,0 shows neutral list
                elif m_item == 'About':
                    screen_about(screen, width, height)
                elif m_item == 'Exit':
                    raise SystemExit
        except KeyboardInterrupt:
            die(screen=screen, err_code=0)
        except SystemExit:
            die(screen=screen, err_code=0)
    
    

def screen_about(screen, width, height):
    # TODO remover sobstory and write about THIS game
    # TODO do as list and iterate over sentences ..
    # Author, license, features (highscore, conway's game of unliving, two-player mode etc.)

    ypos = height // 6
    xpos = width // 10
    draw_header(screen, 'About this game')
    game_title = 'Snek: Snake and Adder'
    game_author = '~ Sigge'
    
    # blurb / sob story
    screen.addstr(ypos, xpos, 'Hi there!')
    ypos += 2
    screen.addstr(ypos, xpos, 'Have you heard about Blockade? Blockade was a monochrome arcade')
    ypos +=1
    screen.addstr(ypos, xpos, 'maze game developed by Gremlin, an arcade game manufacturer based')
    ypos += 1
    screen.addstr(ypos, xpos, 'in San Diego, California. It was designed by Lane Hauck, Ago Kiss,')
    ypos += 1
    screen.addstr(ypos, xpos, 'and Bob Pecarero, and released in October 1976.')
    ypos +=2
    screen.addstr(ypos, xpos, 'Blockade is the first of what would become known as snake games.')
    ypos +=2
    screen.attron(curses.A_ITALIC)
    screen.addstr(ypos, xpos, game_title)
    screen.attroff(curses.A_ITALIC)
    xpos += len(game_title)
    screen.addstr(ypos, xpos, ' was largely created to demonstrate to')
    xpos -= len(game_title)
    ypos += 1
    screen.addstr(ypos, xpos, 'myself that I could write a piece of software in Python.')
    ypos += 2
    screen.addstr(ypos, xpos, 'Many thanks to Al Sweigart for writing his AUTOMATE THE BORING STUFF.')
    ypos += 1
    screen.addstr(ypos, xpos, 'His Conway project prompted me to write this thing.')
    ypos += 2
    screen.addstr(ypos, xpos, 'I hope you enjoy it!')
    ypos += 2
    xpos = width - (len(game_author) + 2)
    screen.attron(curses.A_ITALIC)
    screen.addstr(ypos, xpos, game_author)
    screen.attroff(curses.A_ITALIC)
    screen.refresh()
    screen.getch()
    

def draw_stats(screen, width, height):
    '''Optional intrusive live stats overlay sourced by updated_map()'''
    if zompy_settings['stats_str'] is not None:
        ypos = height - 2
        stats = zompy_settings['stats_str']
        xpos = width - (len(stats) + 2)
        set_font(screen, 'rev', True)
        for xpos in range(xpos, width):
            screen.addstr(ypos, xpos, ' ')
        xpos = width - (len(stats) + 1)
        screen.addstr(ypos, xpos, stats)
        set_font(screen, 'rev', False)


def press_any_key(screen, width, height):
    # Overwrites bottom line of screen with blank spaces and puts 'press any key' text
    status_message(screen, width, height, 'Press any key to continue')
    
    # Draw on screen object
    screen.refresh()
    
    # Wait for input
    try:
        screen.getch()
    except KeyboardInterrupt:
        die(err_code=1, scr=screen)

def status_message(screen, width, height, message):
    for xpos in range(width):
        screen.addstr(height-1, xpos, ' ')
    xpos = width//2 - len(message)//2
    screen.addstr(height-1, xpos, message, curses.A_DIM)

    


def screen_highscore(screen, score, rank, width, height):
    # Show highscore + special message if score in top 3 
    # Remember: Function can be called outside loop too (score = rank = 0)
 
    # debug
    if zompy_settings['debug']: debug_message(scr=screen, msg=f'rank is {rank}')
    
    # Choose a title
    if rank == 1:
        hiscsub = 'You are a GOLD winner!'
    elif rank == 2:
        hiscsub = 'Congratulations, you got the silver!'
    elif rank == 3:
        hiscsub = 'A bronze medal is not bad at all'
    elif rank == 4 or rank == 5:
        hiscsub = 'You are so in the top five!'
    elif rank == 9:
        hiscsub = 'Whew, made it! Bottom of the top of the world!'
    elif rank == 0 and score == 0: # called from outside game (main menu)
        hiscsub = 'Highscores'
    else:
        hiscsub = 'You did fine.. just fine!'

    # Put header on
    draw_header(screen, hiscsub)
    
    # Draw cup ascii
    set_font(screen, 'b', True)
    set_font(screen, 'yellow', True)
    cup_str_0='________'
    cup_str_1='\_ * *_/'
    cup_str_2=')  ('
    cup_str_3="'----`"
    ystart = 3 # height of header + 1
    screen.addstr(ystart, width // 2 - (len(cup_str_0)//2), cup_str_0)
    ystart += 1
    screen.addstr(ystart, width // 2 - (len(cup_str_1)//2), cup_str_1)
    ystart += 1
    screen.addstr(ystart, width // 2 - (len(cup_str_2)//2), cup_str_2)
    ystart += 1
    screen.addstr(ystart, width // 2 - (len(cup_str_3)//2), cup_str_3)
    set_font(screen, 'b', False)
    set_font(screen, 'yellow', False)
    
    
    
    # Find minimum x dimensions (lengths) for table
    col_1_len = len('Rank')
    col_2_len = len('Name')
    col_3_len = len('Score')
    col_4_len = len('2020-04-13') # today (but also any ISO 8601 format date)
    
    # get str len
    if len(zompy_settings['highscore']) > 0:
        for hiscore in zompy_settings['highscore']:
            hiscore_score, hiscore_name, hiscore_date = hiscore
            if len(str(hiscore_score)) > col_3_len:
                col_3_len = len(str(hiscore_score))
            if len(str(hiscore_name)) > col_2_len:
                col_2_len = len(str(hiscore_name))
            if len(str(hiscore_date)) > col_4_len:
                col_4_len = len(str(hiscore_date))
        
          
        xlen = col_1_len + col_2_len + col_3_len + col_4_len
        xstart = width // 2 - ((xlen + 2)//2)
        xstop = xstart + (xlen + 1)
        
        
        # x values
        col_1 = xstart + 1
        col_2 = col_1 + col_1_len + 1
        col_3 = col_2 + col_2_len + 1
        col_4 = col_3 + col_3_len + 1
        
        
        # y is simple = 10 lines + title
        ystart = height // 2 - 3 # was -6
        

        # Draw table title
        set_font(screen, 'subtitle', True)
        for xpos in range(xstart, xstop):
            screen.addstr(ystart, xpos, ' ') # nice yellow (or rev) title background
        screen.addstr(ystart, col_1, 'Rank')
        screen.addstr(ystart, col_2, 'Name')
        screen.addstr(ystart, col_3, 'Score')
        screen.addstr(ystart, col_4, 'Date      ') # must be equal to ISO date str len
        set_font(screen, 'subtitle', False)


        # loop ops
        icount = 0
        ypos = ystart
        
        for hiscore_line in zompy_settings['highscore']:
            ypos += 1
            icount += 1
            hiscore, hiname, hidate = hiscore_line
            if icount < 10: hirank = f' {icount}'
            else: hirank = str(icount)
                
            if icount == rank:
                set_font(screen, 'blink', True) # arcade style
                set_font(screen, 'b', True) # arcade style
            
            # Put data line
            # TODO evaluate alternate line color scheme
            screen.addstr(ypos, col_1, str(hirank+'.'))
            screen.addstr(ypos, col_2, str(hiname))
            screen.addstr(ypos, col_3, str(hiscore))
            screen.addstr(ypos, col_4, str(hidate))
                
            if icount == rank:
                set_font(screen, 'blink', False) # turn it off again
                set_font(screen, 'b', False) # arcade style
            
    else:
        no_entries = 'High score is empty. No records on file yet.'
        ypos = height // 2
        xpos = width // 2 - (len(no_entries)//2)
        screen.addstr(ypos, xpos, no_entries)
    
    # "Press any key" line
    press_any_key(screen, width, height)


def allow_input(screen, set_bool):
    # To be used inside of curses object to toggle on/off main settings for input
    # enables if set_bool is True
    if set_bool is True:
        curses.echo()
        curses.nocbreak()
        screen.keypad(False)
        curses.curs_set(1)
    else:
        curses.noecho()
        curses.cbreak()
        screen.keypad(True)
        curses.curs_set(0)

def enter_player_name(screen, width, height, singleplayer):
    # Prompt player for name/nick to use in highscore or gloat screen
    # Used in both singleplayer (to highscore) or two-player (to gloat_screen)
    
    # lazy constants
    if singleplayer is True:
        put_str = 'Enter your name for the High Score'
    else:
        put_str = 'Please enter your name'
    
    xpad = (len(put_str)//2) + 2
    
    xpos_from = width // 2 - xpad
    xpos_to = width // 2 + xpad
    ypos_from = height // 2 - 2
    ypos_to = height // 2 + 3

    if singleplayer is True:
        players = 1
    else:
        players = 2
    
    player_count = 1
    
    while player_count <= players:
        player_name = 'Player'
        if not singleplayer:
            if player_count == 1:
                player_name += ' 1'
            else:
                player_name += ' 2'

        draw_header(screen, 'High Score') # clear screen
        
        draw_popup(screen, ypos_from, xpos_from, ypos_to, xpos_to, False)
        
        xpos = xpos_from + 3
        ypos = ypos_from + 2
        screen.addstr(ypos, xpos, put_str)            
        ypos += 2 # Please verify

        screen.addstr(ypos, xpos, str(player_name + ': '))
        allow_input(screen, True)
        screen.refresh()
        
        uinput_name =''
        while True:
            try:
                char = screen.getch()
                if char == curses.KEY_ENTER or char in [10, 13] or char == 27:
                    break
                else:
                    try:
                        char = chr(int(char))
                        uinput_name += str(char)
                    except ValueError:
                        pass
            except KeyboardInterrupt:
                uinput_name = ''
                break
            except:
                pass

        
        # remove cursor again
        allow_input(screen, False)
        
        # save if input
        if len(uinput_name) > 0:
            player_name = str(uinput_name)
            if player_count == 1:
                player_1_name = player_name
            else:
                player_2_name = player_name
            player_count += 1
        
    # Provide names for screen_highscore
    if singleplayer:
        return player_1_name
    else:
        return player_1_name, player_2_name


def screen_gloat(screen, width, height):
    # Weak alternative to single player highscore
    True
    # TODO



def highscore(screen, width, height):
    # Calculates SCORE by multiplying PLAY TIME (seconds, int) with generations (int)
    # This ensures that long playtime due to low speed setting do not climb atop the list
    #
    # Appends SCORE to list in zompy_settings['highscore'] which fits top 10 highscores
    # (These are saved to config file by die() later)
    # Finally, show a graphical screen using screen_highscore() with current data
    zompy_settings['score'] = epoch_as_sec() - zompy_settings['score']
    zompy_settings['score'] = int( zompy_settings['countGenerations'] * zompy_settings['score'] )
    if zompy_settings['score'] < zompy_settings['scoreMin']:
        zompy_settings['score'] = zompy_settings['scoreMin']
    elif zompy_settings['score'] > zompy_settings['scoreMax']:
        zompy_settings['score'] = zompy_settings['scoreMax']
    
    # Get player name
    player_name = enter_player_name(screen, width, height, True)
    
    # Get date (ISO 8601)
    play_date = list(time.localtime()[0:3])
    for d in 1, 2:
        if len(str(play_date[d])) == 1:
            play_date[d] = f'0{play_date[d]}'
    play_date = f'{play_date[0]}-{play_date[1]}-{play_date[2]}'
    
    # Append score + name + date to highscore
    zompy_settings['highscore'].append([zompy_settings['score'], player_name, play_date])
    zompy_settings['highscore'].sort(reverse=True)
    hiscore_items = len(zompy_settings['highscore'])
    
    if hiscore_items > 10:
        zompy_settings['highscore'] = zompy_settings['highscore'][:10]
        hiscore_items = 10

    # Find current rank (laziest of evals)
    rank = 100
    for hiscore in range(0,hiscore_items):
        if zompy_settings['highscore'][hiscore][1] == player_name and zompy_settings['highscore'][hiscore][0] == zompy_settings['score']:
            rank = hiscore
    rank +=1 # array start at 0
    
    # debug
    if zompy_settings['debug']: debug_message(scr=screen, msg=f'rank is {rank}')
    
    # If rank too low, demote to insignificance
    if rank > 10: rank = 0
    
    # debug
    if zompy_settings['debug']: debug_message(scr=screen, msg=f'rank adjusted to {rank}')
    
    # Save highscores to file
    save_conf(zompy_config_file)

    # Display highscore
    screen_highscore(screen, zompy_settings['score'], rank, width, height)
    


def die(**kwargs):
    # Clean up function to:
    # Set error code, show goodbye screen, re-set curses and save conf
    # Pass die(err_code=N) where N == 0-255. Empty arg == err_code 0.
    #
    # 0 = no errors (err_code=0 or empty die() works too)
    # 1 = Aborted with CTRL+C
    # 2 = Unknown style choice str
    # 6 = File permission error (cannot open shelve file)
    # 8 = debug halt
    
    
    # Get args (err_code and screen)
    err_code = kwargs.get('err_code', 0)
    scr = kwargs.get('screen', None) # obsolete ?
    
    # Bye-message, use lazy eval
    if err_code == 0:
        die_msg = '\n\nSaving configuration. Thanks for playing.'
    elif err_code == 2:
        die_msg = 'Unknown style choice. You can fix this by amending set_zompy_visuals()'
    elif err_code == 5:
        die_msg = 'Error: items in configFile.items() too many or too few.'
    elif err_code == 6:
        die_msg = '\n\nHalted on file permission error (configFile file r/w error)'
    elif err_code == 8:
        die_msg = '\n\nDebug halt.'
    elif err_code == 9:
        die_msg = 'debug_message() called without providing screen object.'
    else:
        die_msg = f'\n\nAborted with error code {err_code}.'

    # save settings and score(s)
    if err_code == 0: save_conf(zompy_config_file)
    
    if scr is not None:
        curses.nocbreak()
        curses.echo()
        curses.curs_set(1) # re-set cursor settings
        curses.endwin()
    
    print(die_msg, 'Goodbye!', sep='\n', end='\n', flush=True)
    raise SystemExit(err_code)


def gameloop(screen):
    curses.curs_set(0) # remove cursor
    curses.use_default_colors() # allows use of "transparency" with -1 value: curses.init_pair(1, curses.WHITE, -1)

    # Activate colors (must be done after creation of curses 'screen' obj)
    set_zompy_visuals(zompy_settings['style'], zompy_settings['color'])
    
    # Refresh terminal size values
    set_terminal_size()

    # Greet the player
    if zompy_settings['welcome']:
        screen_welcome(screen, zompy_settings['width'], zompy_settings['height'])
    
    # Show menu
    screen_menu(screen, zompy_settings['width'], zompy_settings['height'])
    
    # Refresh terminal size values
    set_terminal_size()
    
    # Make sure we initate correctly
    zompy_settings['reset'] = True
    
    # Activate visual style
    set_zompy_visuals(zompy_settings['style'], zompy_settings['color'])
    
    # Two-player mode
    if zompy_settings['singleplayer'] is False:
        pass # Prompt for names of player 1 (right) and player 2 (left)
        # On same page show instructions about keyboard ctrls and snek colors
    
    # screen.nodelay(True)
    
    # GAME LOOP
    while True:
        # Re-set game if the user changes terminal size
        if zompy_settings['reset_on_termchange']:
            if terminal_size_changed():
                set_terminal_size()
                zompy_settings['reset'] = True
        
        # Reset settings or continue with existing
        if zompy_settings['reset']:
            
            # debug
            if zompy_settings['debug']: debug_message(scr=screen, msg='Running spawn_map()') # debug
            
            # Populate map with zombies
            status_message(screen, zompy_settings['width'], zompy_settings['height'], 'Populating map ..')
            spawn_map(screen)
            
            # Create snake object
            # Initiate snake "snek" with default size and movement settings, and give it a start location on map
            
            snek = snake('snek', zompy_settings['blocks'], zompy_settings['movement'], zompy_settings['colorOne'])
            if zompy_settings['singleplayer']:
                adder = None                
            else:
                status_message(screen, zompy_settings['width'], zompy_settings['height'], 'Adding 2nd snake ..')
                adder = snake('adder', zompy_settings['blocks'], zompy_settings['movement'], zompy_settings['colorTwo']) # player 2
            
            
            # Start SCORE calculation (play time component)
            zompy_settings['score'] = epoch_as_sec() # reset score
            time_to_move = zompy_settings['score']
            
            # Unset reset bool
            zompy_settings['reset'] = False
            
            
        else:
            # debug
 #           screen.addstr(0,0, 'Running update_map()') # debug
 #           debug_char = screen.getch() # debug
            
            if zompy_settings['singleplayer']:
                if zompy_settings['debug']: debug_message(scr=screen, msg=str(snek)) # debug
                
                update_map(snek, None)
#                update_map(snek) # moves zombies and checks for collisions (if so snek.collision = True)
            else:
                if zompy_settings['debug']: debug_message(scr=screen, msg=str(snek), msg2=str(adder))
                
                # TODO
                update_map(snek, adder)
                
                # TODO
                screen.addstr(0,0, 'debug: we must sort out update #2 for adder snek.')
                debug_char = screen.getch() # debug
                die(screen=screen, err_code=8)
        
        
        # Block events according to 'speed' setting
        # TODO alternatively, just block snake but allow player input..?
#        while time.time() < time_to_move:
 #           time.sleep(0.01)
        
        # Increment generations (for score calc)
        zompy_settings['countGenerations'] += 1
        
        # Clear screen
        # TODO do we need this?
#        screen.clear()
        
        # debug
        if zompy_settings['debug']: debug_message(scr=screen, msg='Running draw_map(screen)') # debug
        
        # Draw map on screen
        draw_map(screen)
        
        # debug
        if zompy_settings['debug']: debug_message(scr=screen, msg='Running snek.draw(screen)') # debug
        
        # Draw snake on map
        snek.draw(screen)
        
        # Draw stats (if any)
        if zompy_settings['stats']:
            draw_stats(screen, zompy_settings['width'], zompy_settings['height'])
        
        # debug
#        screen.addstr(0,0, 'Running screen.refresh()') # debug
#        debug_char = screen.getch() # debug
        
#        screen.refresh()
        
 #       debug_char = screen.getch() # debug
                
        # next move available at ..
#        time_to_move = time.time() + zompy_settings['speed']
        
        # TODO
        # Hot seat multiplayer
        # Some re-write to do here
        if zompy_settings['debug']: debug_message(scr=screen, msg='check_collision(snek)', msg2=str(check_collision(snek)))
        
        
        if check_collision(snek):
            # only true iff snake is dead, otherwise diminish and continue
            # snake is dead (size less than 0 blocks)
            
            if zompy_settings['singleplayer']:
            
                # Provide game over message
                if snek.size <= 0:
                    game_over(screen, zompy_settings['width'], zompy_settings['height'], True)
                else:
                    game_over(screen, zompy_settings['width'], zompy_settings['height'], True)
                
                # enable blocking
                screen.timeout(-1)
                
                # Run highscore
                highscore(screen, zompy_settings['width'], zompy_settings['height'])
                
                # kill game
                break
                
        else:               
            # Get key stroke or keep moving
            try:
                #screen.timeout(int(zompy_settings['speed'] * 1000))
                screen.timeout(zompy_settings['speed'])
                key = screen.getch()
                zompy_settings['key_press'] = True # assume keypress
                zompy_settings['uinput'] = 0 # assume same direction
                # 1 = North, 2 = East, 3 = South, 4 = West
                # 2nd player has keys 5, 6, 7, 8 for W, A, S, D
                if key == -1:
                    zompy_settings['key_press'] = False
                else:
                    check_key = get_wasd_input(key) # translate keys (rewrite to 2-player friendly construct)
                    if check_key > 0 and check_key <= 8:
                        zompy_settings['uinput'] = check_key
                    else:
                        if key == curses.KEY_ENTER or key in [10, 13] or key == 104 or key == 72 or key == 27: # enter, h/H or ESC for menu
                            #screen.nodelay(False)
                            screen.timeout(-1)
                            screen_quickmenu(screen, zompy_settings['width'], zompy_settings['height'])
                            #screen.nodelay(True)
                        elif key == 81 or key == 113: # q
                            #screen.nodelay(False)
                            screen.timeout(-1)
                            highscore(screen, zompy_settings['width'], zompy_settings['height']) # calculate and save highscore
                            break # exit loop and start over
                        
                        # Continue with dir 0 (same)
                        zompy_settings['key_press'] = False
                
                
                # Checks for collisions (snake colliding with zombies)
                snek.update_positions(zompy_settings['uinput'])
                
            except ValueError:
                # ignore, just act normal
                zompy_settings['key_press'] = False
                snek.update_positions(0)
                screen.refresh()
            except KeyboardInterrupt:
                # screen.nodelay(False)
                screen.timeout(-1)
                die(screen=screen, err_code=1) # die() with error on CTRL+C
            except SystemExit:
                # screen.nodelay(False)
                screen.timeout(-1)
                die(screen=screen)



# runtime
if __name__ == '__main__':
    print("Let's play Snek!")

    # Initiate settings and map
    # Mutables (dict, lists) behave like globals without the 'global' keyword
    zompy_settings = {}
    zompy_map = {}

    # Menu constructs as lists
    zompy_quickmenu = ['Continue', 'Toggle Stats', 'Restart', 'Main Menu', 'Exit']
    zompy_main_menu = ['Play', 'Highscores', ' ', 'Settings', 'About', ' ', 'Exit']
    zompy_chsetmenu = ['Settings', 'Difficulty level', 'Speed (seconds)', 'Initial Snake Size', 'Zombies to add', ' ', ' ', 'Gameplay' , 'Two-Player Mode', 'Start in motion', 'Reset on terminal size', ' ', ' ', 'Visual', 'Stats overlay', 'Style']        

    # Set configuration file absolute path
    if Path(Path.home()/Path('.config')).is_dir():
        zompy_config_file = Path.home()/Path('.config/zompy') # use XDG
    else:
        zompy_config_file = Path.home()/Path('.zompy') # use dumb

    # Get configuration from file or use defaults
    # This enforces expected structure on input conf file too
    set_game_defaults()

    # Get configuration from file or save new conf to file
    if zompy_config_file.is_file():
        print(f'Reading config from {zompy_config_file}')
        if config_is_sane(zompy_config_file):
            print('Config check OK, loading ..')
            read_conf(zompy_config_file)
    else:
        print(f'Creating config in {zompy_config_file}')
        save_conf(zompy_config_file) # creates new file

    # Show welcome screen (override)
    zompy_settings['welcome'] = True


    # Start game loop in curses wrapper
    # We loop so that >1 game is possible .. (lazy fix)
    # TODO weird curses issues due to this loop, prolly

    while True:
        curses.wrapper(gameloop)
    else:
        die() # not sure if this is executed ... TODO trace
